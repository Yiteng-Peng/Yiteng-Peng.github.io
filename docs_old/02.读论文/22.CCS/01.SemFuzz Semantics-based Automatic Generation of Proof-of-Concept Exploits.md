---
date: 2024-07-20 09:14:58
permalink: /pages/4aef9add0f09
tags: 
  - Fuzzing
  - NLP
  - CCS
  - 2017
---

很早期的一篇文章，探索了如何使用Linux git log或者CVE这种文本信息来指导复现已知的bug，抑或是进一步发现新的bug，“复现”应该是主要的目标，“发现新的”只是偶然的副产物。112个bug中可以复现16个，感觉有点少了。但毕竟是第一个semantics-based，所以也没问题。

主要是两个步骤：1:从漏洞相关文本中提取信息。2:基于语义的fuzzing。

关于Oracle的描述：

> Once an anomalous event (defined corresponding to the vulnerability type) is observed, an alert will be issued to indicate the PoC exploit is successfully generated.

我怀疑他们是手动设计的Oracle。

## SEMANTIC INFORMATION RETRIEVING

### Generating parse tree

由于是自然语言，因此正则表达式效果不好。因此SemFuzz使用了NLP里面的Part-of-Speech (POS) Tagging, Phrase Parsing and Syntactic Parsing技术。

他们首先构造一个parse tree来识别每个词的POS标签，那么parse tree是什么？

> The parse tree is an ordered, rooted tree that represents the syntactic structure of a sentence according to a Context-Free Grammar

![parse tree](https://raw.githubusercontent.com/Yiteng-Peng/imgs-hosting/main/ecfb3b28cec3.png)

> The parent node of each leaf (i.e., the word in the sentence) is the word’s POS tag.

根节点代表开始；中间节点VP代表动词，NP代表名词；叶子结点代表结束，JJ代表形容词，NN代表名词，这样子就表示了每个词的词性，他们使用了`pyStatParser`工具来从Penn Treebanks学习the Probabilistic Context-Free Grammar (PCoFG)，并进而为每个git log和CVE生成对应的parse tree。

不过这里他们没对上面的工具相关的几个术语/数据集做过多解释。

### Retrieving affected version

这个提取倒是容易，用正则表达式提取就好了，不过我怀疑这个正则表达式应该是跟软件项目相关的。应该不完全通用吧，比如Linux有小版本，有带x的版本信息（4.x）但是其他软件都有吗？不过这也不是大事。

值得注意的是他们需要判断包含版本号的parse tree中是否还包含了kernel or linux，否则可能信息在说gcc的版本号或者其他。

### Retrieving vulnerability type

他们通过type来决定什么是anomalous event，即oracle。

首先在70个跟linux相关的CWE中挑选16个，然后尝试在parse tree的noun域中匹配它们，如果没匹配到就去National Vulnerability Database (NVD)用CVE ID去寻找。

### Retrieving vulnerable functions & Retrieving critical variables

对比patch前后的代码找到修改过的代码作为candidate vulnerable functions。并且有以下观察：如果一个函数在CVE中被提及，那么它更可能是有问题的代码，如果一个变量在CVE中被提及，那么它更可能导致问题。

### Retrieving system calls

由于很多的漏洞代码需要由系统调用引起，因此需要找到可能有问题的系统调用，方法如下：

> After manually checking more than 100 CVEs and their corresponding Linux git logs, we find that each system call mentioned in CVE or git log may either trigger the vulnerable function or set up the running environment that is necessary for triggering the vulnerability.

为了建立系统调用和特定变量的联系，作者构造了一个知识库（构造knowledge base的方法前几年是不是很流行？）。

首先通过Linux Programmer Manual（LPM）获得每个system call返回类型和参数类型的对应关系。感觉作者这个地方的思路是：我们要测Kernel->希望去利用文本信息->分析分析文本结构->哦，原来是这种结构啊，那我们就这样这样提取。

如果一个system call的输入名称等于另一个system call的返回名称，则建立两者的关系。

> Note that this operation may map one keyword to several system calls. Once this situation happens, SemFuzz selects the system call that can cover the most keywords.

**感觉局限性很大，但是毕竟据作者所说是第一个semantics-based的fuzzing工作，所以应该也很有指导意义。**

## SEMANTICS-GUIDED FUZZING

### Setting up the Testing Environment

1. 找到受影响的版本，载入对应内核，然后调用a sequence of system call（应该就是上面提取的）。

2. 1️⃣观察内部执行，考虑内核代码的覆盖率。2️⃣跟踪文档中提取的关键变量，但是考虑到不方便每次插桩/运行时观测变量（因为变量可能被优化掉了），因此本文将关键变量上推到参数级别，跟踪关键参数。3️⃣外部观察者（out-box observer）观察有无abnormal event事件发生，例如memory corruption。

### Generating Seed Input

1. 提取漏洞相关的system call放入种子。

2. 将和种子中的call有relation的也放入。

### Coarse-level Mutation

先做粗粒度的mutation，使得可以执行有问题的函数。通过计算每个seed中函数到目标函数的距离来指导mutation，计算比较简单，可以看原文。就是利用可达图的节点距离。

### Fine-grained Mutation

只关注critical variable对应的参数，通过到达patch块的块间距离来衡量突变的优劣。

## Evaluation

基于Syzkaller实现了它们的工具：SemFuzz。

看上去找信息的准确性还不错，找system call，版本号之类的，但是找关键变量没有那么准。

在112个CVE中可以复现18个（16%），94个无法复现，主要原因是：1.其他的CVE复现条件很苛刻，它们可以reach 46/94个函数，可以抵达19/94中的patch block，但是没办法复现。2.有的CVE需要race condition才能出发，这个需要更多时间来尝试触发，毕竟并行情况是不确定的。

Reach和Trigger对应bug的时间低于Syzkaller。从图表来看，这个工具主要还是只能抵达/触发 单个vulnerable function和单个critical variable导致的问题。

本文没有怎么关注Oracle的问题，猜测应该是他们基于的工具讨论了这一点，而这个文章主要关注的是前端怎么更好更快的生成。
